# Основы работы с Unity
Отчет по лабораторной работе #2 выполнил:
- Рыбкин Сергей Денисович
- РИ-300012

Ссылка на репозиторий с проектом
https://github.com/Sergey8Rybkin/Dragon-Picker

Отметка о выполнении заданий:

| Задание | Выполнение | Баллы |
| ------ | ------ | ------ |
| Задание 1 | * | 60 |
| Задание 2 | # | 20 |
| Задание 3 | # | 20 |

знак "*" - задание выполнено; знак "#" - задание не выполнено;

Работу проверили:
- к.т.н., доцент Денисов Д.В.
- к.э.н., доцент Панов М.А.
- ст. преп., Фадеев В.О.


Лабораторная работа № 2 Интеграция сервиса для получения данных
профиля пользователя.

Цель работы: создание интерактивного приложения и изучение принципов
интеграции в него игровых сервисов.

Задание 1.
По теме видео практических работ 1-5 повторить реализацию игры на Unity. Привести описание выполненных действий.

Для начала создаём репозиторий нашей игры. Нас интересует Core 3D, называем наш проект Dragon Picker.

Далее же начальным этапом является ознакомление с "Asset Store" и выгрузка от туда первого asset пака.
      -Скачиваем и импортируем
![Снимок экрана (8)](https://user-images.githubusercontent.com/100475554/195134791-88cb51df-468c-4831-b0bc-8287a4631f07.png)

Нас интересует один из префабов драконов. Мой выбор пал на DragonUsurper
Делаем копию и добавляем папку нашей сцены. Так-же из ассет пака нас интересует достать и настроить анимацию дракона. Дублируем Idle анимацию в наш проект. Чтобы наш дракон "ожил" создаём Animator controller, добавляем в него Idle анимацию, и перетаскиванием добавляем AC нашему дракону. Вынеся на сцену можем наблюдать нашего "ожившего" enemy.

![Sh4VVLXHqb](https://user-images.githubusercontent.com/100475554/195137797-f06de2b8-1a7d-4233-ac43-72ad2b551ace.gif)

Создаём яйцо
-Создаём на сцене сферу
-Даём ей значения 1, 1.5, 1
-Создаём материал чтобы покрасить наше яйцо (пипеткой можно в одну из частей дракона)
-Наносим материал

![image](https://user-images.githubusercontent.com/100475554/195140151-24a8c8c3-31ec-4e19-b92c-24a4b9f9f952.png)

Ещё нам нужно чем-то ловить наши яйца. 
Создаём сферу, увеличиваем, размещаем чуть ниже дракона.
Так-же нам для сферы нужен материал
Получаем картинку ниже

![eA02unz84m](https://user-images.githubusercontent.com/100475554/195142330-913da81a-b9ca-41e5-bc8f-eb6d9a5bafb3.gif)

В следующей части задания, нам необходимо выставить удобные значения камеры, и написать скрипт перемещения для нашего дракона.      

Начнём с камеры. Нам нужно сделать так чтобы камера была максимально удобна и информативна для нашего игрока
Задаём ей значения 
![image](https://user-images.githubusercontent.com/100475554/195143191-1685eaf4-68e7-4f78-9d6d-0119e02ae816.png)

И получаем такую игровую сцену. Также настраиваем Aspect ratio 16.9 тк это является стандартным разрешением

![LaRKb07HDf](https://user-images.githubusercontent.com/100475554/195143675-1ce91cc6-910d-4537-b8bf-dd0e3bcd4515.gif)

Переходим к программированию скрипта нашего дракона
На сцене наш дракон должен
1. Перелетать по сцене
2. При этом он не должен улетать за края экрана
3. При этом должен это делать "случайным образом

Создаём C# script.
Для начала инициализируем переменные которые мы сможем изменять при отладке: скорость, время между падением яиц, дистанция на которую дракон перемещается влево и вправо, и шанс изменения направления
Каждый кадр мы хотим чтобы наш дракон перемещался по сцене, и не хотим чтобы он улетал дальше заданной дистанции. Прописываем это в нашем скрипте.
Для случайности перемещения, мы делаем проверку. Каждый кадр передаём случайное значение. Если оно будет меньше нашей заданной величины, обращаем движение дракона.

В результате получаем вот такой скрипт
```c#
using UnityEngine;

public class EnemyDragon : MonoBehaviour
{

    public float speed = 1;

    public float timeBetweenEggDrops = 1f;

    public float leftRightDistance = 10f;

    public float changeDirection = 0.01f;
    // Start is called before the first frame update
    void Start()

    }
    // Update is called once per frame
    void Update()
    {
        Vector3 pos = transform.position;
        pos.x += speed * Time.deltaTime;
        transform.position = pos;

        if (pos.x < -leftRightDistance){
            speed = Mathf.Abs(speed);
        }
        else if (pos.x > leftRightDistance) {
            speed = -Mathf.Abs(speed);
        }
    }


    private void FixedUpdate() {
        if (Random.value < changeDirection) {
            speed *= -1;
        }
    }
}
```
И вот такой результат на сцене

![oGwNFY4Vbr](https://user-images.githubusercontent.com/100475554/195147411-30810bae-46d4-4799-b2c4-46615eff0e9f.gif)

